---
title: '🐣 三角形を積んでいくパズル'
topics: ['1a_dharma']
authors:
    - tokunaga
description: 'If you can construct a hexagon, you can score points'
pubDate: 'Jan 10 2024'
heroImage: '/img/hex.jpg'
---

## 着想

定番のゲームとして知られるテトリスやぷよぷよは，落ちてくるブロックを上手に配置して消していく「落ちゲー」として親しまれています．
今回は，その逆のアプローチから新しいゲームを考えてみましょう．
「四角形を使わない」，「地面側のみ操作」や「ブロックがまっすぐ落下しない」といった視点で，「拾いゲー」を開発してみることにしました．

## ゲームの概要

以下の要件を満たす仕様を考えてみます．

| 観点                       | 構成                                                                                 |
| -------------------------- | ------------------------------------------------------------------------------------ |
| フィールド                 | 正六角形(2D)                                                                         |
| 操作可能なオブジェクト     | 一辺の長さ`x`の正三角形                                                              |
| 落下オブジェクト           | 一辺の長さ`x`の正三角形が様々な順番で連なったもの                                    |
| 落下オブジェクトの移動方向 | 四隅にいる動物がそれぞれ左下，右下，右上，左上めがけて落下オブジェクトを順に射出     |
| オブジェクトの消える条件   | 六角形を揃えたとき                                                                   |
| ゲームオーバーとなる条件   | オブジェクトを消せ切れず，プレイヤーと結合したオブジェクトが境界をこえてしまったとき |

まだ穴だらけですが，コアとなりそうな基本概念はこの辺にしておき，仕様は開発しながら煮詰めていく想定です．

## コンポーネントとシステム

まずは唯一操作可能となるプレイヤーからつくります．
ゼロサイズの構造体は Query Filter でのみ利用します．
マーカコンポーネントといったりします．

```rust title={core::player}
#[derive(Component, Default, Debug)]
pub struct Player;
```

Player エンティティを生成します．
`SpriteBundle` を利用し，"tri.png"(三角形の画像)をテクスチャとして適用します．
そして先ほどのマーカコンポーネントを追加しておきます．

`EDGE_LENGTH` はまだ未定ですが，一辺の長さとしています．

```rust title={service::player}
pub fn install_dharma(mut cmds: Commands, asset_server: Res<AssetServer>) {
    cmds.spawn((
        SpriteBundle {
            texture: asset_server.load("tri.png"),
            sprite: Sprite {
                custom_size: Some(Vec2::new(EDGE_LENGTH, EDGE_LENGTH)),
                ..default()
            },
            transform: Transform::from_xyz(100., 0., 0.),
            ..default()
        },
        RotatedShape::Upright,
    ))
    .insert(Player);
}
```

また，キー入力によって上下左右に移動する機能も実装する必要があります．
ただし，ここで二つの選択肢があります．

1. 無段階の移動(座標の値が精緻な実数)
2. 1 回の移動距離を一定(座標の値がすべて定数，既知)

前者が滑らかに落ちるぷよぷよ方式，後者がカクカクと落ちるテトリス方式です．
今回は後者で進めます．
